---
title: " Using Subgraphs for Flipside Labels "
author: " Graham Onders "
date: "`r Sys.Date()`"
output:
  html_document:
    css: "styles.css"
    includes:
      in_header: header.html
    code_folding: hide
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

# Intro

FlipsideCrypto's Research is open source. Check out all the code for this report [here](https://github.com/fsc-data-science/Subgraphs-for-Labels) on github.

```{r, warning = FALSE, message = FALSE}
# Libraries
library(shroomDK)
library(reactable)
# library(ggplot2)
# library(plotly)
# library(lubridate)
# library(dplyr)
```


# What are Subgraphs?

Subgraphs are a product of [The Graph](https://thegraph.com/), which provide an industry standard on how to access blockchain data via open APIs. There are subgraphs for many things like governance, ENS, dex/defi liquidity pools and more! Many protocols leverage custom built subgraphs to track activity within their ecosystem! 

Since these subgraphs are open, we can also tap into the data and label contract addresses! Predominantly, we focused on dex and defi protocols, in order to find any liquidity pools that belong to each protocol. 

In order to be able to tap into these open APIs we are going to leverage Flipside Crypto's LiveQuery capabilities, which allows us to call an API within our SQL statements. 
For more information revolving around the LiveQuery basics, check out our previous [Beehive article](https://flipsidecrypto.beehiiv.com/p/real-time-crypto), which summarizes and provides examples of different ways to use LiveQuery, or check out our [docs](https://flipsidecrypto.github.io/livequery-models/).


# How can Subgraphs be Leveraged?

```{r, warning = FALSE, message = FALSE}


subgraph_query = {
"
  with raw as (
        SELECT
            livequery.live.udf_api(
                'POST',
                'https://api.thegraph.com/subgraphs/name/messari/uniswap-v3-ethereum',
                {'Content-Type': 'application/json'},
                {'query':'{\n  liquidityPools(first: 100, orderBy: totalValueLockedUSD, orderDirection: desc) {
                  \n    id\n    totalValueLockedUSD\n    name\n  
                    inputTokens { \n id \n symbol \n }}\n}',
                'variables':{}
                },
                ''
            ) as rawoutput
        )
  select
  value:id :: string as pool_address,
  value:name :: string as pool_name,
  value:totalValueLockedUSD :: int as totalValueLockedUSD,
  value:inputTokens[0]:id :: string as token0_address,
  value:inputTokens[1]:id :: string as token1_address,
  value:inputTokens[0]:symbol :: string as token0_symbol,
  value:inputTokens[1]:symbol :: string as token1_symbol
  from raw, lateral flatten(input => parse_json(rawoutput:data:data:liquidityPools))
  "
}


# not run 
# subgraph_liquiditypools <- auto_paginate_query(query = subgraph_query, api_key = readLines("api_key.txt"))

# provided pre-ran 
subgraph_liquiditypools <- read.csv("subgraph_liquiditypools.csv",
                               colClasses=c("POOL_ADDRESS"="character", "TOKEN0_ADDRESS"="character","TOKEN1_ADDRESS"="character"))
colnames(subgraph_liquiditypools) <- tolower(colnames(subgraph_liquiditypools))

```

Subgraphs can be leveraged fairly easily using Flipside's livequery capabilities within a standard SQL statement. In the query above, we make a call to Messari's Ethereum Uniswap V3 subgraph. We ask for the first 100 liquidity pools ordered by the total value that is locked in the pool in terms of USD. We can then parse the API's response in SQL and output a nice clean table!


```{r, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
reactable(subgraph_liquiditypools,columns = list(
  totalvaluelockedusd = colDef(format = colFormat(prefix = "$", separators = TRUE, digits = 0))
),
    resizable = TRUE)
```


And Viola! We have the top 100 pools on Uniswap based on TVL, as well as the pool address and the token address and symbol that comprise the pool! The interoperability of Flipside's livequery and subgraphs becomes quite apparent! 

Here at flipside, we use this exact process to discover pools across many defi and dex protocols in order to add them to our address labels tables! 


# What Subgraphs does Flipside use?

Flipside uses only trusted subgraphs for their labels. We use subgraphs that are created by the actual protocol (ie. Uniswap creating a Uniswap subgraph), as well as trusted subgraphs from protocols like Messari.

All of these subgraphs are compiled and scanned for new labels every day! In total we are scanning over 400 subgraphs, including many of the top defi protocols, to ensure that we have complete and accurate labels. 

These subgraphs include:
```{r, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
all_subgraphs = read.csv("all_subgraphs.csv")
reactable(all_subgraphs, resizable = TRUE)
```


# Where are these labels stored?

All subgraph labels are stored both in the crosschain.core.address_labels table, which holds all labels for all chains, and in the relevant [blockchain].core.dim_labels table. 

These labels can easily be joined to a query to provide clarity and context around addresses!







